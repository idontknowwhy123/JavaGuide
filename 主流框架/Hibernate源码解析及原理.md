1.hibernate源码解析：https://blog.csdn.net/qq_34988540/article/details/82563947
2.hibernate工作原理：https://blog.csdn.net/hsj1213522415/article/details/78168469

1.hibernate级联
https://blog.csdn.net/weixin_43184769/article/details/82845664

//128、Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？</br> 
答：SessionFactory对应Hibernate的一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。SessionFactory一般只会在启动的时候构建。对于应用程序，最好将SessionFactory通过单例模式进行封装以便于访问。Session是一个轻量级非线程安全的对象（线程间不能共享session），它表示与数据库进行交互的一个工作单元。Session是由SessionFactory创建的，在任务完成之后它会被关闭。Session是持久层服务对外提供的主要接口。Session会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的session，可以使用ThreadLocal将session和当前线程绑定在一起，这样可以让同一个线程获得的总是同一个session。Hibernate 3中SessionFactory的getCurrentSession()方法就可以做到。</br>
129、Hibernate中Session的load和get方法的区别是什么？</br> 
答：主要有以下三项区别：
 load采用的是延迟加载的方式 而get不是 
① 如果没有找到符合条件的记录，get方法返回null，load方法抛出异常。 
② get方法直接返回实体类对象，load方法返回实体类对象的代理。 
③ 在Hibernate 3之前，get方法只在一级缓存中进行数据查找，如果没有找到对应的数据则越过二级缓存，直接发出SQL语句完成数据读取；load方法则可以从二级缓存中获取数据；从Hibernate 3开始，get方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。
hibernate对于load方法认为该数据在数据库中一定存在，可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，只能抛异常；而对于get方法首先在session缓存中查找，然后在二级缓存中查找，还没有就查数据库，数据库中没有就返回null。</br>
延迟加载：Hibernate中主要是通过代理（proxy）机制来实现延迟加载，Hibernate丛数据库获取某一个对象数据时，hibernate并不是立刻从数据库加载真正的数据，而只是为该对象创建一个代理对象来代表这个对象，只有在真正需要使用该对象的数据时才创建这个真实对象，这样就可以提高查询效率。</>
说明：对于load()方法Hibernate认为该数据在数据库中一定存在可以放心的使用代理来实现延迟加载，如果没有数据就抛出异常，而通过get()方法获取的数据可以不存在。</br>

131、阐述Session加载实体对象的过程。</br> 
答：Session加载实体对象的步骤是： 
① Session在调用数据库查询功能之前，首先会在一级缓存中进行查找，如果一级缓存查找命中，则直接返回； 
② 如果一级缓存没有命中，接下来Session会在当前NonExists记录（相当于一个查询黑名单，如果出现重复的无效查询可以迅速做出判断，从而提升性能）中进行查找，如果NonExists中存在同样的查询条件，则返回null； 
③ 如果一级缓存查询失败则查询二级缓存，如果二级缓存命中则直接返回； 
④ 如果之前的查询都未命中，则发出SQL语句，如果查询未发现对应记录则将此次查询添加到Session的NonExists中加以记录，并返回null； 
⑤ 根据映射配置和SQL语句得到ResultSet，并创建对应的实体对象； 
⑥ 将对象纳入Session（一级缓存）的管理； 
⑦ 如果有对应的拦截器，则执行拦截器的onLoad方法； 
⑧ 如果开启并设置了要使用二级缓存，则将数据对象纳入二级缓存； 
⑨ 返回数据对象。</br>

132、Query接口的list方法和iterate方法有什么区别？</br> 
答： ① list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。 
② list()方法不会引起N+1查询问题，而iterate()方法可能引起N+1查询问题
说明：关于N+1查询问题，可以参考CSDN上的一篇文章《什么是N+1查询》</br>

133、Hibernate如何实现分页查询？</br> 
答：通过Hibernate实现分页查询，开发人员只需要提供HQL语句（调用Session的createQuery()方法）或查询条件（调用Session的createCriteria()方法）、设置查询起始行数（调用Query或Criteria接口的setFirstResult()方法）和最大查询行数（调用Query或Criteria接口的setMaxResults()方法），并调用Query或Criteria接口的list()方法，Hibernate会自动生成分页查询的SQL语句。

135、阐述实体对象的三种状态以及转换关系。</br> 
答：最新的Hibernate文档中为Hibernate对象定义了四种状态（原来是三种状态，面试的时候基本上问的也是三种状态），分别是：瞬时态（new, or transient）、持久态（managed, or persistent）、游离态（detached）和移除态（removed，以前Hibernate文档中定义的三种状态中没有移除态），如下图所示，就以前的Hibernate文档中移除态被视为是瞬时态。

瞬时态：当new一个实体对象后，这个对象处于瞬时态，即这个对象只是一个保存临时数据的内存区域，如果没有变量引用这个对象，则会被JVM的垃圾回收机制回收。这个对象所保存的数据与数据库没有任何关系，除非通过Session的save()、update（）等方法把瞬时态对象与数据库关联，这个对象才转换为持久态对象。
持久态：持久态对象的实例在数据库中有对应的记录。对持久态对象进行delete操作后，数据库中对应的记录将被删除，那么持久态对象与数据库记录不再存在对应关系，持久态对象变成为瞬时态。持久态对象被修改变更后，不会马上同步到数据库，直到数据库事务提交。
游离态：当Session进行了close()、clear()或flush()后，实体对象从持久态变成游离态，对象虽然拥有持久和与数据库对应的记录，但是因为对象已经从会话中清除掉，对象不在持久化管理之内，所以处于游离态（也叫脱管态）。游离态的对象与临时状态对象是十分相似的，只是它还含有持久化标识。
提示：关于这个问题，在Hibernate的官方文档中有更为详细的解读。

136、如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？</br> 
答：延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate使用了虚拟代理机制实现延迟加载，我们使用Session的load()方法加载数据时返回给用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用getter方法时才会去数据库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。
延迟加载与session关闭的矛盾一般可以这样处理： 
① 关闭延迟加载特性。这种方式操作起来比较简单，因为Hibernate的延迟加载特性是可以通过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现"no session or session was closed"通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询的开销都会变得很大。 
② 在session关闭之前先获取需要查询的数据，可以使用工具方法Hibernate.isInitialized()判断对象是否被加载，如果没有被加载则可以使用Hibernate.initialize()方法加载对象。 
③ 使用拦截器或过滤器延长Session的生命周期直到视图获得数据。Spring整合Hibernate提供的OpenSessionInViewFilter和OpenSessionInViewInterceptor就是这种做法。

137、举一个多对多关联的例子，并说明如何实现多对多关联映射。</br> 
答：例如：商品和订单、学生和课程都是典型的多对多关系。可以在实体类上通过@ManyToMany注解配置多对多关联或者通过映射文件中的和标签配置多对多关联，但是实际项目开发中，很多时候都是将多对多关联映射转换成两个多对一关联映射来实现的。

138、谈一下你对继承映射的理解。 </br>
答：继承关系的映射策略有三种： 
① 每个继承结构一张表（table per class hierarchy），不管多少个子类都用一张表。 
② 每个子类一张表（table per subclass），公共信息放一张表，特有信息放单独的表。 
③ 每个具体类一张表（table per concrete class），有多少个子类就有多少张表。 
第一种方式属于单表策略，其优点在于查询子类对象的时候无需表连接，查询速度快，适合多态查询；缺点是可能导致表很大。后两种方式属于多表策略，其优点在于数据存储紧凑，其缺点是需要进行连接查询，不适合多态查询。</br>

139、简述Hibernate常见优化策略。 
答：这个问题应当挑自己使用过的优化策略回答，常用的有： 
① 制定合理的缓存策略（二级缓存、查询缓存）。 
② 采用合理的Session管理机制。 
③ 尽量使用延迟加载特性。 
④ 设定合理的批处理参数。 
⑤ 如果可以，选用UUID作为主键生成器。 
⑥ 如果可以，选用基于版本号的乐观锁替代悲观锁。 
⑦ 在开发过程中, 开启hibernate.show_sql选项查看生成的SQL，从而了解底层的状况；开发完成后关闭此选项。 
⑧ 考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观的提升，但这些需要专业的DBA（数据库管理员）提供支持。

140、谈一谈Hibernate的一级缓存、二级缓存和查询缓存。</br> 
答：Hibernate的Session提供了一级缓存的功能，默认总是有效的，当应用程序持久化实体对象时，Session并不会立即把这种改变提交到数据库，而是缓存在当前的Session中，除非显示调用了Session的flush()方法或通过close()方法关闭Session。通过一级缓存，可以减少程序与数据库的交互，从而提高数据库访问性能。 
SessionFactory级别的二级缓存是全局性的，所有的Session可以共享这个二级缓存。不过二级缓存默认是关闭的，需要显示开启并指定需要使用哪种二级缓存实现类（可以使用第三方提供的实现）。一旦开启了二级缓存并设置了需要使用二级缓存的实体类，SessionFactory就会缓存访问过的该实体类的每个对象，除非缓存的数据超出了指定的缓存空间。 
一级缓存和二级缓存都是对整个实体进行缓存，不会缓存普通属性，如果希望对普通属性进行缓存，可以使用查询缓存。查询缓存是将HQL或SQL语句以及它们的查询结果作为键值对进行缓存，对于同样的查询可以直接从缓存中获取数据。查询缓存默认也是关闭的，需要显示开启。
141、Hibernate中DetachedCriteria类是做什么的？ 
答：DetachedCriteria和Criteria的用法基本上是一致的，但Criteria是由Session的createCriteria()方法创建的，也就意味着离开创建它的Session，Criteria就无法使用了。DetachedCriteria不需要Session就可以创建（使用DetachedCriteria.forClass()方法创建），所以通常也称其为离线的Criteria，在需要进行查询操作的时候再和Session绑定（调用其getExecutableCriteria(Session)方法），这也就意味着一个DetachedCriteria可以在需要的时候和不同的Session进行绑定。
142、@OneToMany注解的mappedBy属性有什么作用？ 
答：@OneToMany用来配置一对多关联映射，但通常情况下，一对多关联映射都由多的一方来维护关联关系，例如学生和班级，应该在学生类中添加班级属性来维持学生和班级的关联关系（在数据库中是由学生表中的外键班级编号来维护学生表和班级表的多对一关系），如果要使用双向关联，在班级类中添加一个容器属性来存放学生，并使用@OneToMany注解进行映射，此时mappedBy属性就非常重要。如果使用XML进行配置，可以用<set>标签的inverse="true"设置来达到同样的效果。
