秒杀系统设计
1.限流
1.1、Nginx限流
       三种方式：1、limit_conn_zone：客户端的并发连接数最大值
2、limit_req_zone：来限制单位时间内的请求数，即速率限制,采用的漏桶算法。
漏桶(Leaky Bucket)算法思路很简单,水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求,可以看出漏桶算法能强行限制数据的传输速率.
令牌桶算法(Token Bucket)和 Leaky Bucket 效果一样但方向相反的算法,更加容易理解.随着时间流逝,系统会按恒定1/QPS时间间隔(如果QPS=100,则间隔是10ms)往桶里加入Token(想象和漏洞漏水相反,有个水龙头在不断的加水),如果桶已经满了就不再加了.新请求来临时,会各自拿走一个Token,如果没有Token可拿了就阻塞或者拒绝服务.
令牌桶的另外一个好处是可以方便的改变速度. 一旦需要提高速率,则按需提高放入桶中的令牌的速率.
1.2、站点层限流（基于redis实现限流功能）：
假设一个用户（用IP判断）每分钟访问某一个服务接口的次数不能超过10次，那么我们可以在Redis中创建一个键，并此时我们就设置键的过期时间为60秒，每一个用户对此服务接口的访问就把键值加1，在60秒内当键值增加到10的时候，就禁止访问服务接口。在某种场景中添加访问时间间隔还是很有必要的。

2.队列削峰
通过第一步限流后，将合法流量放到一个队列中，实现流量削峰，达到流量可控和异步处理。
秒杀的数量有限，我们可以先将库存数量放置到一个缓存当中，然后每次将请求放入到队列中时都提前判断下，库存数量是否大于0：
1.如果库存大于0，表示还有库存，则将请求放入到队列中，并将库存递减1，该过程可能需要分布式锁来解决并发问题
2.如果库存小于0,则表示库存不足，直接返回失败，

3.缓存
3.1利用缓存应对读请求：对类似于12306等购票业务，是典型的读多写少业务，大部分请求是查询请求，所以可以利用缓存分担数据库压力。
