一.redis缓存穿透以及解决方案
https://www.cnblogs.com/lingyejun/p/10087135.html
1.缓存空对象

2.布隆过滤器拦截

2.布隆过滤器的原理
https://www.jianshu.com/p/2104d11ee0a2

布隆过滤器优点
它的优点是空间效率和查询时间都远远超过一般的算法，布隆过滤器存储空间和插入 / 查询时间都是常数O(k)。另外,
散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。

布隆过滤器缺点
但是布隆过滤器的缺点和优点一样明显。误算率是其中之一。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。

另外，一般情况下不能从布隆过滤器中删除元素. 我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加 1, 这样删除元素时将计数器减掉就可以了。
然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面. 这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题

二.缓存击穿以及解决方案
定义：缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，
这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。

解决方案：
1.使用互斥锁
就是只让一个线程构建缓存，其他线程等待构建缓存的线程执行完，重新从缓存获取数据就可以了

2.永不过期
我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建
从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。
原理：https://www.cnblogs.com/chengege/p/11073166.html

三.缓存雪崩
定义：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。
事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略->缓存的过期时间应该随机均匀分布，防止某一个时刻大面积的缓存失效。（主从模式）
事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉
事后：利用 redis 持久化机制保存的数据尽快恢复缓存
![](https://camo.githubusercontent.com/5026cff9341b3049578f9a05bdf60b2ec62f28d3/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32352f363037383336372e6a7067)

补充：1.缓存的过期时间应该随机均匀分布，防止某一个时刻大面积的缓存失效
     2.加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法！

代码实现：https://blog.csdn.net/zeb_perfect/article/details/54135506?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4

四.单线程的redis为什么那么快
  1.redis是基于内存的，内存的读写速度非常快；
  2.redis是单线程的，省去了很多上下文切换线程的时间；
  3.redis使用多路复用技术，可以处理并发的连接；
  IO多路复用技术：指的其实是在单个线程通过记录跟踪每一个Sock(I/O流)的状态(对应空管塔里面的Fight progress strip槽)来同时管理多个I/O流
  epoll与select,poll的区别
  1.select:注册多个socket到select,然后循环遍历这些socket，一旦有数据到达，socket被激活,select函数返回。用户线程正式发起read请求，
  读取数据并继续执行
  
  缺点：每个IO请求过程还是阻塞的
  epoll采用异步的方式来解决这种阻塞问题
  
  2.epoll:通过Reactor的方式，可以将用户线程轮询IO操作状态的工作统一交给Refactor线程进行处理，然后自己去处理自己的事情
  用户线程注册事件处理器之后可以继续执行做其他的工作（异步），而Reactor线程负责调用内核的select函数检查socket状态。当有socket被激活时，
  则通知相应的用户线程（或执行用户线程的回调函数），执行handle_event进行数据读取、处理的工作
  https://blog.csdn.net/Happy_wu/article/details/80052617?utm_medium=distribute.pc_relevant_right.none-task-blog-BlogCommendFromMachineLearnPai2-5.nonecase&depth_1-utm_source=distribute.pc_relevant_right.none-task-blog-BlogCommendFromMachineLearnPai2-5.nonecase
  
五.redis的数据结构及使用场景
  1. String
常用命令: set,get,decr,incr,mget 等。

String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。

  2.Hash
常用命令： hget,hset,hgetall 等。

Hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以Hash数据结构来存储用户信息，商品信息等等。比如下面我就用 hash 类型存放了我本人的一些信息：

key=JavaUser293847
value={
  “id”: 1,
  “name”: “SnailClimb”,
  “age”: 22,
  “location”: “Wuhan, Hubei”
}

   3.list

list 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。

Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。

另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。

  4.set
  set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。

当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。

比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：

sinterstore key1 key2 key3     将交集存在key1内
 
  5.sortSet
 和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。

举例： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 SortedSet 结构进行存储


六，redis的过期策略
Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。

我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。

如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？

定期删除+惰性删除。

通过名字大概就能猜出这两个删除方式的意思了。

定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，
每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！

惰性删除 ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，
才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，
此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？
 
redis 提供 6种数据淘汰策略：

volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）.
allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
no-enviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧

LRU算法
https://blog.csdn.net/WhereIsHeroFrom/article/details/86501571?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5

redis分布式锁
1.基于zoopkeeper的实现
https://blog.csdn.net/wuzhiwei549/article/details/80692278?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1
2.redission分布式锁原理及实现
https://blog.csdn.net/shuangyueliao/article/details/89344256
https://www.cnblogs.com/qdhxhz/p/11046905.html

-### redis哨兵
     1.为什么要用到哨兵？
       哨兵主要是为了解决主从架构中出现宕机的情况：
       1.1、从redis宕机
            从redis重启之后会自动加入到redis集群中，并主动从主机同步数据。
       1.2、主redis宕机
            在从redis服务器中执行slave no one命令断开主从关系，并选举一个从服务器升级为主服务器
            将其他从服务器通过slave of命令设置为新的主服务器的从服务器
      
     2.哨兵机制的高可用
        2.1、哨兵机制是解决redis高可用的解决方案：一个哨兵系统由一个或多个哨兵组成，每个哨兵会监视各个redis主服务器以及其对应的从服务器，一旦某个主服务器宕机下线，
             哨兵将会从该主服务器的从服务器中选举一个从服务器升级为主服务器
        2.2、哨兵的定时监控
             2.2.1、对redis集群信息的获取
                    每个哨兵每隔10s会向主节点和从节点发送info命令获取整个集群的拓扑图
             2.2.2、对主节点的判断
                    每个哨兵每隔2s会向redis节点的指定频道发送主节点的判断以及当前哨兵的信息，其他哨兵都订阅了该频道，所以每个哨兵都能感知到其他哨兵对主节点的判断
             2.2.3、判断节点是否宕机的依据
                    每个哨兵每隔1s会向主节点，从节点和其他哨兵发送一次ping命令做一次心跳检查
         2.3、主观下线：
              就是单个哨兵通过心跳检查机制判断某个节点不正常了，宕机了
              
              客观下线：当主观下线的节点是主节点，当前哨兵就会向其他哨兵发送指令通知其他哨兵去对该主节点进行判断，当有其他节点也认为该主节点不正常了，
                        并且认为该主节点不正常的哨兵个数超过选举数量时，哨兵则认为该主节点是客观下线了
                        
         2.4、哨兵leader选举流程：
              当某个哨兵判断某个主节点已经客观下线了，他将会向其他哨兵请求申请自己为故障转移的leader，其他哨兵收到请求之后可以选择同意和不同意
              当同意的哨兵实例数量大于等于（哨兵数量/2+1）时，该哨兵将被选为哨兵leader进行故障转移
              
         2.5、故障转移机制
              2.5.1、哨兵leader将按照如下规则从从节点中选举出新的主节点：
                    1.排除下线的主节点
                    2.选举slave-priority最高的从节点，如果有则返回没有则继续
                    3.选举复制偏移量最大的节点，如果有就返回没有则继续
                    4.选举run_id最小的节点
                    
              2.5.2、更新主从状态：
                     1.首先通过slaveof no one命令让选举出来的从节点成为新的主节点，然后通过slave of命令让其他从节点成为该主节点的从节点
                     2.将下线的主节点设置为新的主节点的从节点，当恢复正常时，重新从主节点复制数据
                    
           参考资料：
           https://www.jianshu.com/p/06ab9daf921d
           https://blog.csdn.net/u012240455/article/details/81843714?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase
           https://www.cnblogs.com/Eugene-Jin/p/10819601.html



-### redis的hash一致算法
     当数据量很大时，我们需要对redis进行分库分表操作，将数据均匀的分配到各个redis节点上。
     1.随机分配：查询的时候需要遍历各个redis服务器进行查询，
           缺陷：性能差
     2.使用hash算法进行分配：假设有4台redis服务器，对数据的key进行hash算法的计算并对4求余从而确定某一台redis服务器
                      缺陷：当redis服务器数量发生变化时，很多缓存的位置都会发生变化，也就是说很多缓存在某一定时间内是失效的，缓存数据失效，
                            则会向后台数据库请求数据             
     3.使用一致性hash算法进行分配：
       3.1算法原理:1、一致性hash算法是对2^32-1取模，然后将整个Hash值控件组织成一个虚拟的圆环，构造成一个哈希环
                   整个空间按照顺时针方向组织，圆环的正上方的点代表0,0点右侧第一个点代表1，直到2^32-1,
                   2、接下来将服务器根据IP或者主机名使用一个哈希函数找到其环空间位置
                   3、接下来使用数据的key根据相同的哈希函数定位到环上的某一位置，并从该位置开始，沿顺时针行走，遇到的第一个服务器就是存储该数据的服务器
       3.2一致性hash算法的容错性与扩展性
           容错性：当某一台服务器出现问题，受影响的仅仅是当前问题服务器到前一台服务器（逆时针行走遇到的第一台服务器）的所有数据，其他数据不会受影响
           扩展性：当新增一台服务器时，受影响的仅仅是新增加的这台服务器到前一台服务器（逆时针行走遇到的第一台服务器）的所有数据，其他数据不会受影响
           综上所述：一致性HASH算法对于哈希环上节点的增减，只会影响到环上的一小部分数据，具有较好的容错性和扩展性
       3.3哈希环的数据倾斜问题
           问题：在服务器节点过少时，由于服务器节点分布不均匀导致数据倾斜（被缓存的对象大部分都集中在某一台服务器上）
       解决办法：对每一个服务器节点计算多个hash值，每一个hash位置都放置一个服务节点，称为虚拟节点，然后构造一个虚拟节点到真实节点的映射    


-### redis的持久化策略
     1、RDB：将某一时刻的数据通过快照的方式保存在磁盘中
       
       1.1、手动触发：
            1.1.1、save命令会阻塞Redis服务器，直到RDB创建快照文件结束，阻塞耗时太长，已废弃
            1.1.2、bgsave命令会fork一个子进程，由子进程来完成快照文件的创建工作，阻塞发生在fork子进程，fork子进程耗时较短
            
       1.2、自动触发：
            1.2.1、配置save选项：save  60 10000，redis从最近一次创建快照开始算起，当60s时间内有10000次写入操作时就会触发bgsave命令
            1.2.2、如果从节点执行全量复制操作，则主节点自动执行bgsave命令生成RDB快照文件并发送给从节点。
            1.2.3、当redis服务器通过SHUTDOWN命令接收到关闭服务器请求时，将会执行save命令
            
       1.3、RDB执行流程：
            1.3.1、执行bgsave首先判断是否存在RDB或AOF的子进程，如果存在，直接返回
            1.3.2、父进程fork操作创建一个子进程，fork操作会阻塞父进程
            1.3.3、fork完成后，子进程开始根据父进程的内存生成临时快照文件，完成后对原有RDB文件进行替换
            1.3.4、子进程完成快照文件的创建和替换工作后会给父进程发送信号，父进程再更新统计信息
            
        1.4、RDB的优缺点：
             优点：
             1.4.1、RDB快照文件是一个紧凑压缩的二进制文件，体积较小
             1.4.2、Redis加载RDB恢复数据远远快于AOF的方式
             缺点：
             1.4.3、redis宕机之后将会丢失最近一次创建快照之后写入的所有数据
             
      2、AOF:以日志的形式记录每一次的写命令，AOF持久化会将被执行的写命令追加到AOF文件的末尾 
         
         2.1
                                

