1.B+树
https://www.jianshu.com/p/71700a464e97
2.mysql事务隔离级别
快照数据是指该行之前的版本数据，实现是通过undo日志来完成的，又称为MVCC机制（多版本并发控制）
RC隔离级别：总是读取最新的快照数据，所以会出现不可重复读的并发问题
RR隔离级别，总是读取事物开始时的快照数据，不会出现不可重复读的并发问题
https://www.cnblogs.com/huanongying/p/7021555.html
3.MYSQL MVCC 实现机制
https://blog.csdn.net/whoamiyang/article/details/51901888
4.innodb间隙锁，记录锁(行锁)
https://www.jianshu.com/p/bf862c37c4c9
5.各种锁以及意向锁存在的意义
https://blog.csdn.net/u010841296/article/details/84204701
6.覆盖索引，聚集索引，非聚集索引
覆盖索引与联合索引的区别？
没有区别，覆盖索引只是特定于具体select语录而言的联合索引。
也就是说一个联合索引对于某个select语句，通过索引可以直接获取查询结果，而不再需要回表查询啦，就称该联合索引覆盖了这条select语句。
https://blog.csdn.net/itguangit/article/details/82145322

SQL优化（总览：sql慢 绝大多数情况下是没有触发索引，进行的是全局检索。哪些情况会检索全表呢？主要分为3种）
explain sql 用于分析 慢sql

一、索引失效的情况
1.where 子句中对于字段的null值的判断。
应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：	
select id from t where num is null	
可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：	
select id from t where num=0	

2.where子句中的不确定性的判断。
2.1.in 和 not in 也要慎用，否则会导致全表扫描，如：	
select id from t where num in(1,2,3)	
对于连续的数值，能用 between 就不要用 in 了：	
select id from t where num between 1 and 3	
	
2.2.下面的查询也将导致全表扫描：	
select id from t where name like '%abc%'
如果是符合左前缀，即可走索引
比如 like abc%
	
2.3.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：	
select id from t where num/2=100	
应改为:	
select id from t where num=100*2	
	
2.4.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：	
select id from t where substring(name,1,3)='abc'--name以abc开头的id	
应改为:	
select id from t where name like 'abc%'	
	
2.5.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。	

2.6.select from table where col_vchar=123，这个 SQL 产生了隐式转换，col_vchar 字段是一个 varchar 类型，但传入的值却是数字类型，
这样 col_vchar 字段上会默认加一个 to_number 的函数，无法使用索引，全表扫描，你需要重点注意一下这样看着简单但很容易被忽略的 SQL 。

2.7.col_utf8mb4=col_utf8，大家要注意这种情况，尽量两个表的关联列类型都是 varchar，但字符集不相同，同样无法使用索引，
你在日常优化 SQL 和设计表结构时一定要注意，尽量采用 utf8mb4 为默认字符集，如果两个表字符集不同，则需要提前变更一下。

二、什么情况下需要创建索引。
数据量要大。
where 后经常出现的列。
数据种类要多。不能像 性别 一样 只有两种。Cardinality值：表示索引中不重复记录数量的预估值，Cardinality/rows应尽可能接近1
读多写少的。 因为insert 和 update 都会更新索引。

三、索引的类型
2.索引类型
普通索引INDEX：适用于name、email等一般属性
唯一索引UNIQUE：与普通索引类似，不同的是唯一索引要求索引字段值在表中是唯一的，这一点和主键索引类似，但是不同的是，唯一索引允许有空值。
唯一索引一般适用于身份证号码、用户账号等不允许有重复的属性字段上。
主键索引：其实就是主键，一般在建表时就指定了，不需要额外添加。
全文检索：只适用于VARCHAR和Text类型的字段。
注意：全文索引和普通索引是有很大区别的，如果建立的是普通索引，一般会使用like进行模糊查询，只会对查询内容前一部分有效，即只对前面不使用通配符的查询有效，如果前后都有通配符，普通索引将不会起作用。对于全文索引而言在查询时有自己独特的匹配方式，例如我们在对一篇文章的标题和内容进行全文索引时：
ALTER TABLE article ADD FULLTEXT ('title', 'content'); 在进行检索时就需要使用如下的语法进行检索：
SELECT * FROM article WHERE MATCH('title', 'content') AGAINST ('查询字符串');
在使用全文检索时的注意事项：
MySql自带的全文索引只能用于数据库引擎为MYISAM的数据表，如果是其他数据引擎，则全文索引不会生效。此外，MySql自带的全文索引只能对英文进行全文检索，目前无法对中文进行全文检索。如果需要对包含中文在内的文本数据进行全文检索，我们需要采用Sphinx（斯芬克斯）/Coreseek技术来处理中文。另外使用MySql自带的全文索引时，如果查询字符串的长度过短将无法得到期望的搜索结果。MySql全文索引所能找到的词默认最小长度为4个字符。另外，如果查询的字符串包含停止词，那么该停止词将会被忽略。
3.组合索引
组合索引又称多列索引，就是建立索引时指定多个字段属性。有点类似于字典目录，比如查询 'guo' 这个拼音的字时，首先查找g字母，然后在g的检索范围内查询第二个字母为u的列表，最后在u的范围内查找最后一个字母为o的字。比如组合索引(a,b,c)，abc都是排好序的，在任意一段a的下面b都是排好序的，任何一段b下面c都是排好序的
组合索引的生效原则是  从前往后依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引没有起作用；
造成断点的原因：
前边的任意一个索引没有参与查询，后边的全部不生效。
前边的任意一个索引字段参与的是范围查询，后面的不会生效。
断点跟索引字字段在SQL语句中的位置前后无关，只与是否存在有关。在网上找到了很好的示例：
比如：
where a=3 and b=45 and c=5 .... #这种三个索引顺序使用中间没有断点，全部发挥作用；
where a=3 and c=5... #这种情况下b就是断点，a发挥了效果，c没有效果
where b=3 and c=4... #这种情况下a就是断点，在a后面的索引都没有发挥作用，这种写法联合索引没有发挥任何效果；
where b=45 and a=3 and c=5 .... #这个跟第一个一样，全部发挥作用，abc只要用上了就行，跟写的顺序无关
（a,b,c） 三个列上加了联合索引（是联合索引 不是在每个列上单独加索引）而是建立了a,(a,b),(a,b,c)三个索引，另外(a,b,c)多列索引和 (a,c,b)是不一样的。
具体实例可以说明：
(0) select * from mytable where a=3 and b=5 and c=4;
#abc三个索引都在where条件里面用到了，而且都发挥了作用
(1) select * from mytable where  c=4 and b=6 and a=3;
#这条语句为了说明 组合索引与在SQL中的位置先后无关，where里面的条件顺序在查询之前会被mysql自动优化，效果跟上一句一样
(2) select * from mytable where a=3 and c=7;
#a用到索引，b没有用，所以c是没有用到索引效果的
(3) select * from mytable where a=3 and b>7 and c=3;
#a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引
(4) select * from mytable where b=3 and c=4;
#因为a索引没有使用，所以这里 bc都没有用上索引效果
(5) select * from mytable where a>4 and b=7 and c=9;
#a用到了  b没有使用，c没有使用
(6) select * from mytable where a=3 order by b;
#a用到了索引，b在结果排序中也用到了索引的效果，前面说了，a下面任意一段的b是排好序的
(7) select * from mytable where a=3 order by c;
#a用到了索引，但是这个地方c没有发挥排序效果，因为中间断点了，使用 explain 可以看到 filesort
(8) select * from mytable where b=3 order by a;
#b没有用到索引，排序中a也没有发挥索引效果


四、sql优化经验
(一) 使用查询缓存优化查询
大多数的MySQL服务器都开启了查询缓存。这是提高性能最有效的方法之一，而且这是被MySQL引擎处理的。当有很多相同的查询被执行了多次的时候，
这些查询结果会被放入一个缓存中，这样后续的相同查询就不用操作而直接访问缓存结果了。
这里最主要的问题是，对于我们程序员来说，这个事情是很容易被忽略的。因为我们某些查询语句会让MySQL不使用缓存，示例如下：
1：SELECT username FROM user WHERE    signup_date >= CURDATE()
2：SELECT username FROM user WHERE    signup_date >= '2014-06-24‘
上面两条SQL语句的差别就是 CURDATE() ，MySQL的查询缓存对这个函数不起作用。所以，像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，
因为这些函数的返回是会不定的易变的。所以，你所需要的就是用一个变量来代替MySQL的函数，从而开启缓存。

(二)在join表的时候使用相当类型的列，并将其索引
如果在程序中有很多JOIN查询，应该保证两个表中join的字段时被建立过索引的。这样MySQL内部会启动优化JOIN的SQL语句的机制

（三）禁止使用 order by rand()。
order by rand() 会为表增加几个伪列，然后用 rand() 函数为每一行数据计算 rand() 值，最后基于该行排序，
这通常都会生成磁盘上的临时表，因此效率非常低。建议先使用 rand() 函数获得随机的主键值，然后通过主键获取数据。

(四)避免使用SELECT *
从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果我们的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。
所以，我们应该养成一个需要什么就取什么的好的习惯。

（五）group by 和 order by 的优化
分组和排序都涉及排序，故尽量在索引中包含排序字段，并让排序字段的排序顺序与索引列中的顺序相同，这样可以避免排序或减少排序次数。
比如 where a=? order by b,c，就可以创建一个索引 (a,b,c)。

（六）limit分页优化
 1.语法：
      *** limit [offset,] rows
      一般是用于select语句中用以从结果集中拿出特定的一部分数据。
      offset是偏移量，表示我们现在需要的数据是跳过多少行数据之后的，可以忽略；rows表示我们现在要拿多少行数据。
      2.栗子：
      ①select * from mytbl limit 10000,100
      上边SQL语句表示从表mytbl中拿数据，跳过10000行之后，拿100行
      ②select * from mytbl limit 0,100
      表示从表mytbl拿数据，跳过0行之后，拿取100行
      ③select * from mytbl limit 100
      这条SQL跟②的效果是完全一样的，表示拿前100条数据
      3.用处：
      我目前用到的地方是数据库查询分页，比如前台要展示数据库中数据，需要后台实现分页，传入数据要有“页码page”跟“每页数据条数nums”。
      对应SQL大概是这样子：select * from mytbl order by id limit (page-1)*nums,nums
      4.问题发现：
      在数据量不大或者是大数据量的前几页的时候，性能还算不坏，但是大数据量页码稍微大一点性能便下降比较严重。
      5.问题分析：
      原因出在Limit的偏移量offset上，比如limit 100000,10虽然最后只返回10条数据，但是偏移量却高达100000，数据库的操作其实是拿到100010数据，然后返回最后10条。
      那么解决思路就是，我能不能跳过100000条数据然后读取10条，而不是读取100010条数据然后返回10条数据。
      6.问题解决实现：
      原SQL语句如下：
      select * from mytbl order by id limit 100000,10  改进后的SQL语句如下：
      select * from mytbl where id >= ( select id from mytbl order by id limit 100000,1 ) limit 10 
      注：假设id是主键索引，那么里层走的是索引，外层也是走的索引，所以性能大大提高
      
  (七)select/update/delete 语句中没有 where 或者 where 中无索引字段
      这样的 SQL 都没有使用索引，会造成全表扫描，update 和 delete 语句还会加表级锁，阻塞其他并发的 SQL。



面试
数据库如何查询大数据
数据库建立索引有哪些注意的地方
数据库索引有哪些
