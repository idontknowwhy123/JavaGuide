1.二叉排序树（二叉查找树）<br>
什么是二叉排序树？<br>
（1）若它的左子树不为空，则左子树上的所有结点的值均小于它的根结点的值。<br>
 (2) 若它的右子树不为空，则右子树上的所有结点的值均大于它的根结点的值。<br>
 (3) 它的左，右子树也分别为二叉排序树。<br>
 
一、二叉排序树的结点类。<br>
下方这段代码就是二叉排序树的结点类，该类的结构与之前我们聊二叉树时的结构没什么区别。因为二叉排序树的物理存储结构也是通过二叉链表的形式来组织的，
所以下方的BinaryTreeNote中data字段用于存储结点数据，leftChild用来指向左孩子，rightChild用来指向右孩子。<br>
![](https://images2015.cnblogs.com/blog/545446/201610/545446-20161027152114859-1136331254.png)

二、二叉排序树的查找实现
首先我们先创建一个类，也就是下方的SearchResult类，该类中存储的就是每次查找返回的结果。下方就是对每个结点的介绍：<br>
searchNote字段存储的就是查找到的节点，如果未查找到，那么该结点就为空。<br>
fatherNote字段就负责存储当前查到节点的父节点，如果该节点为空，那么当前查到的节点就为根节点。如果查找失败，那么我们的结点将要挂到fatherNote节点上。<br>
isFound字段负责存储查找的结果，如果二叉排序树中有要查找的节点，那么该字段为true, 如果没有，该字段就为false。<br>
![](https://images2015.cnblogs.com/blog/545446/201610/545446-20161027153358328-1262356431.png)
实现完查找结果的存储类后，接下来我们就该实现我们的查找方法了。下方这个searchBST()方法就是我们二叉排序树的查找方法，该方法有三个参数，第一个参
数currentRoot是当前二叉排序树的根节点，当然在每次递归遍历时该参数就是每轮递归时子树的根节点。第二个参数是fatherNote，也就是第一个参数currentRoot
的父节点，如果currentRoot是整个二叉排序树的根节点的话，那么fatherNote就为空。而第三个参数就是我们要匹配的关键字key。该方法的返回值就是上
面SearchResult的对象，该对象中存储的就是查找的相关结果。<br>

查找步骤:<br>
1.首先创建存储查找结果的对象searchResult，以备下方查找时使用。<br>
2.然后判断currentRoot是否为空，如果为nil说明没有找到key相应的结点。根据此结果设置searchResult的值，并返回searchResult。<br>
3.紧接着在判断key是否等于currentRoot.data, 如果等于就说明我们找到了相应的结点，根据此结果设置searchResult的值，并返回searchResult对象。<br>
4.如果没有查找失败，也没有查找成功，我们就比较key是否小于currentRoot.data，如果小于的话，说明我们的key有可能位于左子树上，然后递归查找左子树。
如果key大于currentRoot.data, 那么说明我们的key有可能位于右子树上，递归查找右子树。<br>
![](https://images2015.cnblogs.com/blog/545446/201610/545446-20161027154726390-426502527.png)

三、二叉排序树的插入操作<br>
二叉排序树的插入操作就显得比较简单了，因为再查找的返回结果中，如果查找失败，那么返回结果中也会有fatherNote。这个FatherNote就是我们将要插入节点
的父节点。不过二叉排序树为空树时，查找结果的fatherNote为空，所以我们先判断fatherNote节点是否为空，如果为nil的话，我们就把当前关键字key对应
的结点作为二叉排序树的根结点。如果fatherNote不为nil, 那么我们就判断key是否大于fatherNote.data, 如果大于的话，我们就把key作为fatherNote的
右结点，否则作为fatherNote的左结点。具体代码如下所示。<br>
![](https://images2015.cnblogs.com/blog/545446/201610/545446-20161027162152953-8758792.png)

四、二叉排序树的创建<br>
上面我们实现了二叉排序树的搜索和插入的代码，上面我们不止一次的提到过，二叉排序树的创建就是不断查找和插入的过程。也就是先对要插入的结点key
进行查找，如果二叉排序树上没有该key的话，就需要根据查找结果将key插入的二叉排序树中相应的位置上。下方代码就是二叉排序树的创建，就是先查找，
如果没找到就插入，具体代码如下所示：<br>
![](https://images2015.cnblogs.com/blog/545446/201610/545446-20161027163550734-887246973.png)

五、二叉排序树的删除<br>
二叉排序树的结点删除要比二叉排序树结点的插入要复杂一些，不过也并不难，要分为几种情况进行讨论。二叉排序树结点的插入与删除都是在查找的基础上来做的。
下方我们就假设找到了我们要删除的结点，根据结点含有的左右结点的个数来进行分类讨论。下方会对这几种情况进行讨论。<br>

1.删除结点的几种情况<br>
(1)、删除结点为叶子结点<br>
删除的结点没有左子树也没有右子树，也就是删除的结点为叶子结点。这种情况下我们有可以细分为两类，一种是该叶子结点就是二叉排序树的根节点，
也就是二叉排序树中只有一个节点的情况。只需要将root指针置为空即可。再一种情况是有删除的叶子节点有父节点，直接将父节点连接该删除节点的指针置空即可。<br>
示意图如下所示：<br>
![](https://images2015.cnblogs.com/blog/545446/201610/545446-20161027180850343-1418989221.png)

(2)、删除的结点只有左子树的情况<br>
该情况也可以细分为两类，一种是该删除的结点没有父节点，也就删除的节点为根节点，我们需要将根节点的root指针指向即将删除结点的左孩子，然后将删除结点的leftChild置空即可。如果该结点有父节点，那么将父节点相应的孩子指针指向删除节点的左孩子，然后将删除节点的leftChild置空。<br>
![](https://images2015.cnblogs.com/blog/545446/201610/545446-20161027180901875-1089278752.png)

(3)、删除的结点只有右子树的情况<br>
该情况也可以细分为两类，一种是该删除的结点没有父节点，也就删除的节点为根节点，我们需要将根节点的root指针指向即将删除结点的右孩子，然后将删除结点的rightChild置空即可。如果该结点有父节点，那么将父节点相应的孩子指针指向删除节点的右孩子，然后将删除节点的rightChild置空。<br>
![](https://images2015.cnblogs.com/blog/545446/201610/545446-20161027180913015-679473089.png)

(4)、删除结点中既有右子树又有左子树的情况<br>
这种情况会稍微复杂一些，我们采用覆盖，再删除的方式进行解决。也就是曲线解决。直接将有左子树也有右子树的结点干掉似乎不是很好实现，因为这样会破坏二叉排序树的结果。我们可以间接的去做。可以分为下方的两步。<br>
第一步：查找删除结点右子树中最小的那个值，也就是右子树中位于最左方的那个结点。然后将这个结点的值的父节点记录下来。并且将该节点的值赋给我们要删除的结点。也就是覆盖。<br>
第二步：然后将右子树中最小的那个结点进行删除，该节点肯定符合上述三种情况的情况(1)或者情况(3)，所以可以使用上述的方法进行删除。<br>
这样一来我们就间接的删除了既有左子树也有右子树的结点。具体示意图如下所示:<br>
![](https://images2015.cnblogs.com/blog/545446/201610/545446-20161027180926781-1560369713.png)

二叉排序树得平均时间复杂度为O（log(n)）









 
