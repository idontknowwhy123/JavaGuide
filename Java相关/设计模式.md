下面是自己学习设计模式的时候做的总结，有些是自己的原创文章，有些是网上写的比较好的文章，保存下来细细消化吧！

1.单例模式
1.1 定义
保证一个类仅有一个实例，并提供一个访问它的全局访问点。

1.2 为什么要用单例模式呢？
在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。

简单来说使用单例模式可以带来下面几个好处:

1.对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；
2.由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。

1.3 为什么不使用全局变量确保一个类只有一个实例呢？
我们知道全局变量分为静态变量和实例变量，静态变量也可以保证该类的实例只存在一个。
只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。

但是，如果说这个对象非常消耗资源，而且程序某次的执行中一直没用，这样就造成了资源的浪费。利用单例模式的话，我们就可以实现在需要使用时才创建对象，这样就避免了不必要的资源浪费。 不仅仅是因为这个原因，在程序中我们要尽量避免全局变量的使用，大量使用全局变量给程序的调试、维护等带来困难。

2.单例模式的实现方式
通常单例模式在Java语言中，有两种构建方式：
2.1.饿汉方式。指全局的单例实例在类装载时构建
2.2.懒汉方式。指全局的单例实例在第一次被使用时构建。

不管是那种创建方式，它们通常都存在下面几点相似处：
2.3.单例类必须要有一个 private 访问级别的构造函数，只有这样，才能确保单例不会在系统中的其他代码内被实例化;
2.4.instance 成员变量和 uniqueInstance 方法必须是 static 的。

1.饿汉方式（线程安全）
public class Singleton{
  private static Singleton singleton = new Singleton();
  private Singleton(){}
  public static Singleton getInstance(){
     return singleton;
  }
}
所谓 “饿汉方式” 就是说JVM在加载这个类时就马上创建此唯一的单例实例，不管你用不用，先创建了再说，如果一直没有被使用，便浪费了空间，典型的空间换时间，每次调用的时候，就不需要再判断，节省了运行时间。

2.懒汉式（非线程安全以及synchronized线程安全版本）
非线程安全：
public class Singleton{
  private static Singleton singleton;
  private Singleton(){}
  public static Singleton getInstance(){
       if(singleton = null){
          singleton = new Singleton();
       } 
  }
}

所谓 “ 懒汉式” 就是说单例实例在第一次被使用时构建，而不是在JVM在加载这个类时就马上创建此唯一的单例实例。
但是上面这种方式很明显是线程不安全的，如果多个线程同时访问getInstance()方法时就会出现问题。如果想要保证线程安全，一种比较常见的方式就是在getInstance() 方法前加上synchronized关键字，如下：
public class Singleton{
  private static Singleton singleton;
  private Singleton(){}
  public static synchronized Singleton getInstance(){
       if(singleton = null){
          singleton = new Singleton();
       } 
  }
}
我们知道synchronized关键字偏重量级锁。虽然在JavaSE1.6之后synchronized关键字进行了主要包括：为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升。

但是在程序中每次使用getInstance() 都要经过synchronized加锁这一层，这难免会增加getInstance()的方法的时间消费，而且还可能会发生阻塞。我们下面介绍到的 双重检查加锁版本 就是为了解决这个问题而存在的。

3.懒汉式（双重检查锁定）
public class Singleton{
 private voliate static Singleton singleton;
 private Singlrton(){}
 public static Singleton getInstance(){
   if(singleton == null){
      synchronized(){
         if(singleton == null){
               singleton = new Singleton();           
         }
      }
   }
   return singleton;
 }
}
很明显，这种方式相比于使用synchronized关键字的方法，可以大大减少getInstance() 的时间消费。

4.懒汉式（静态内部类）
静态内部实现的单例是懒加载的且线程安全。

只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance（只有第一次使用这个单例的实例的时候才加载，同时不会有线程安全问题）。
public class Singleton{
  private static class SingletonHolder{
     private static final Singleton single = new Singleton();
  }
  public static final Singleton getInstance(){
     return SingletonHolder.single;
  }
}

5.饿汉式枚举方式（）
这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。 它更简洁，自动支持序列化机制，绝对防止多次实例化 （如果单例类实现了Serializable接口，默认情况下每次反序列化总会创建一个新的实例对象，关于单例与序列化的问题可以查看这一篇文章《单例与序列化的那些事儿》），同时这种方式也是《Effective Java 》以及《Java与模式》的作者推荐的方式
public enum Singleton{
   INSTANCE;
}
## 创建型模式：

> ### 创建型模式概述：

- 创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。
- 创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。 

![创建型模式](https://user-gold-cdn.xitu.io/2018/6/16/1640641afcb7559b?w=491&h=241&f=png&s=51443)

> ### 创建型模式系列文章推荐：

- **单例模式：**

[深入理解单例模式——只有一个实例](https://blog.csdn.net/qq_34337272/article/details/80455972)

- **工厂模式：**

[深入理解工厂模式——由对象工厂生成对象](https://blog.csdn.net/qq_34337272/article/details/80472071)

- **建造者模式：**

[深入理解建造者模式 ——组装复杂的实例](http://blog.csdn.net/qq_34337272/article/details/80540059)

- **原型模式：**

[深入理解原型模式 ——通过复制生成实例](https://blog.csdn.net/qq_34337272/article/details/80706444)


## 结构型模式：

> ### 结构型模式概述：

- **结构型模式(Structural Pattern)：** 描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构
![结构型模式(Structural Pattern)](https://user-gold-cdn.xitu.io/2018/6/16/164064d6b3c205e3?w=719&h=233&f=png&s=270293)
- **结构型模式可以分为类结构型模式和对象结构型模式：**  
   - 类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。
   - 对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。

![结构型模式](https://user-gold-cdn.xitu.io/2018/6/16/1640655459d766d2?w=378&h=266&f=png&s=59652)

> ### 结构型模式系列文章推荐：

- **适配器模式：**

[深入理解适配器模式——加个“适配器”以便于复用](https://segmentfault.com/a/1190000011856448)

[适配器模式原理及实例介绍-IBM](https://www.ibm.com/developerworks/cn/java/j-lo-adapter-pattern/index.html)

- **桥接模式：**

[设计模式笔记16：桥接模式(Bridge Pattern)](https://blog.csdn.net/yangzl2008/article/details/7670996)

- **组合模式：**

[大话设计模式—组合模式](https://blog.csdn.net/lmb55/article/details/51039781)

- **装饰模式：**

[java模式—装饰者模式](https://www.cnblogs.com/chenxing818/p/4705919.html)

[Java设计模式-装饰者模式](https://blog.csdn.net/cauchyweierstrass/article/details/48240147)

- **外观模式：**

[java设计模式之外观模式（门面模式）](https://www.cnblogs.com/lthIU/p/5860607.html)

- **享元模式：**

[享元模式](http://www.jasongj.com/design_pattern/flyweight/)

- **代理模式：**

[代理模式原理及实例讲解 （IBM出品，很不错）](https://www.ibm.com/developerworks/cn/java/j-lo-proxy-pattern/index.html)

[轻松学，Java 中的代理模式及动态代理](https://blog.csdn.net/briblue/article/details/73928350)

[Java代理模式及其应用](https://blog.csdn.net/justloveyou_/article/details/74203025)


## 行为型模式

> ### 行为型模式概述：

- 行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。
- 行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。
- 通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。 

**行为型模式分为类行为型模式和对象行为型模式两种：**

- **类行为型模式：** 类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。
- **对象行为型模式：** 对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。

![行为型模式](https://user-gold-cdn.xitu.io/2018/6/28/164467dd92c6172c?w=453&h=269&f=png&s=63270)

- **职责链模式：**

[Java设计模式之责任链模式、职责链模式](https://blog.csdn.net/jason0539/article/details/45091639)
  
[责任链模式实现的三种方式](https://www.cnblogs.com/lizo/p/7503862.html)

- **命令模式：**



- **解释器模式：**
- **迭代器模式：**
- **中介者模式：**
- **备忘录模式：**
- **观察者模式：**
- **状态模式：**
- **策略模式：**
- **模板方法模式：**
- **访问者模式：**

